#!/usr/bin/env bash

pushd "$(dirname "$0")"
for file in *.js
do
  rm -rf copy.db
  printf "%s\t(%s)\n" "`{ gtime -f "%es / %P" node "$file"; } 2>&1`" "${file%.*}"
done
rm -rf copy.db

# 111.49s / 14% (fs::copyFile)
# 110.19s / 14% (fs::copyFileSync)
# 106.25s / 14% (bsd::copyfile)
#
# 128.81s / 95% (c++::fstream)
# 85.77s / 80%  (fs::stream)
# 81.18s / 81%  (db::backup)
#
# 82.40s / 62%  (c::fopen)
# 78.69s / 43%  (posix::open)

# Supposedly 'fopen' is faster than 'open' for small operations (e.g., line by
# line) because it buffers output, where 'open' doesn't. But for large loads,
# 'open' is faster because buffering doesn't accomplish anything in that case.
#
# Streaming also seems to be competitive in speed, but has higher CPU usage,
# which seems to be a trade-off for the ability to do other things concurrently.
#
# BSD's copyfile is somehow slower than simple read/write operations (not sure
# about the reason), but is able to save on CPU usage (probably by bypassing the
# copy into user space).
